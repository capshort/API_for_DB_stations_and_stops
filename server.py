#!/usr/bin/env python

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from pandas import read_csv
from sys import argv, exit
from os.path import exists


# initialise the flask webserver and the SQLAlchemy database depending on it
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/stations.sqlite'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

class Station(db.Model):
    plc = db.Column(db.String(20), unique=True, nullable=True)
    rl100_code = db.Column(db.String(20), primary_key=True)
    rl100_langname = db.Column(db.String(100), unique=True, nullable=False)
    rl100_kurzname = db.Column(db.String(80), unique=True, nullable=False)
    typ_kurz = db.Column(db.String(5), nullable=False)
    typ_lang = db.Column(db.String(5), nullable=False)
    betriebszustand = db.Column(db.String(20), )
    ab_datum = db.Column(db.Date, nullable=False) # TODO implement a converter from format "20220128" to "2022-01-28" which is used in SQL
    bis_datum = db.Column(db.Date)
    niederlassung = db.Column(db.Integer, nullable=False)
    regionalbereich = db.Column(db.String(80), nullable=False)
    letzte_aenderung = db.Column(db.Date, nuallable=False)
    
    # serialisation includes all instance parameters minus the one auto-generated by SQLAlchemy
    def serialise(self):
        result = vars(self)
        del result['_sa_instance_state']
        return result

@app.get('/betriebsstelle/<string:identifier>')
def getStation(identifier):
    # identifier may be one of: plc, rl100_code, rl100_langname, rl100_kurzname
    # and if it is a rl100_code it may be lower or upper case (the db stores them upper cased)
    result = Station.query.filter_by(rl100_code=identifier.upper()).all()
    if len(result) > 0:
        return jsonify(result[0].serialise()), 200
    for query_column in [ plc, rl100_langname, rl100_kurzname ]:
        result = Station.query.filter_by(query_column=identifier)
        if len(result) > 0:
            return jsonify(result[0].serialise()), 200
    return {"Fehler": "Angefragte Betriebsstelle existiert nicht"}, 406

if __name__ == '__main__':
    # determine csv input file & ensure that the database initially contains exactly that file's entries
    csv_file = argv[1] if len(sys.argv) > 1 else './DBNetz-Betriebsstellenverzeichnis-Stand2021-10.csv'
    if (not os.path.exists(csv_file)):
        sys.exit("A valid csv file must be given as argument!")
    db.drop_all()
    read_csv(csv_file, sep=";").to_sql(Station.__tablename__, db.engine, index=False)
    
    # start the server
    app.run(host='0.0.0.0', port=8080)
